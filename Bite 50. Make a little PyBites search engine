"""
Use feedparser to create a command line app to search tags from RSS feed. It should support AND, OR searches as well.
"""

from collections import namedtuple
from datetime import date, datetime
import feedparser
from time import mktime

FEED = 'https://bites-data.s3.us-east-2.amazonaws.com/all.rss.xml'

Entry = namedtuple('Entry', 'date title link tags')


def _convert_struct_time_to_dt(stime):
    """Convert a time.struct_time as returned by feedparser into a
    datetime.date object, so:
    time.struct_time(tm_year=2016, tm_mon=12, tm_mday=28, ...)
    -> date(2016, 12, 28)
    """
    return date.fromtimestamp(mktime(stime))


def get_feed_entries(feed=FEED):
    """Use feedparser to parse PyBites RSS feed.
       Return a list of Entry namedtuples (date = date, drop time part)
    """
    parsed = feedparser.parse(feed)
    return [Entry(_convert_struct_time_to_dt(item['published_parsed']), item['title'], item["link"], [t['term'].lower() for t in item['tags']]) for item in parsed.entries]

def filter_entries_by_tag(search, entry):
    """Check if search matches any tags as stored in the Entry namedtuple
       (case insensitive, only whole, not partial string matches).
       Returns bool: True if match, False if not.
       Supported searches:
       1. If & in search do AND match,
          e.g. flask&api should match entries with both tags
       2. Elif | in search do an OR match,
          e.g. flask|django should match entries with either tag
       3. Else: match if search is in tags
    """
    terms = entry[3]

    if "&" in search:
        if all(item.lower() in terms for item in search.split("&")):
            return True
        else:
            return False
    elif "|" in search:
        if any(item.lower() in terms for item in search.split("|")):
            return True
        else:
            return False
    elif search.lower() in terms:
            return True
    else:
        return False

def main():
    """Entry point to the program
       1. Call get_feed_entries and store them in entries
       2. Initiate an infinite loop
       3. Ask user for a search term:
          - if enter was hit (empty string), print 'Please provide a search term'
          - if 'q' was entered, print 'Bye' and exit/break the infinite loop
       4. Filter/match the entries (see filter_entries_by_tag docstring)
       5. Print the title of each match ordered by date ascending
       6. Secondly, print the number of matches: 'n entries matched'
          (use entry if only 1 match)
    """
    entries = get_feed_entries()

    while True:
        search_for = input("Search for (q for exit): ")
        if search_for == "q":
            print("Bye")
            break
        elif search_for == "":
            print("Please provide a search term \n")
        else:
            results = []
            for entry in entries:
                check = filter_entries_by_tag(search_for, entry)
                if check == True:
                    results.append(f"{entry[0]} | {entry[1]} | {entry[2]}")
            for result in sorted(results):
                print(result)
            if len(results) == 1:
                print(f"1 entry matched \"{search_for}\"")
            elif len(results) > 1:
                print(f"\n{len(results)} entries matched \"{search_for}\"")
            else:
                print(f"\n0 entries matched \"{search_for}\"")




if __name__ == '__main__':
    main()
